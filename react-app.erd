<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.8.2-beta1" last-position="74,36" last-zoom="1.1"
	 default-schema="public" default-owner="postgres">
<role name="authenticator"
      encrypted="true"
      password="********">
</role>

<role name="super"
      superuser="true"
      encrypted="true"
      password="********">
</role>

<role name="anon"
      inherit="true"
      encrypted="true"
      password="********">
	<roles names="authenticator" role-type="member" />
</role>

<role name="author"
      inherit="true"
      encrypted="true"
      password="********">
	<roles names="authenticator" role-type="member" />
</role>

<database name="react-app" encoding="UTF8" lc-collate="en_ZA" lc-ctype="en_ZA">
	<role name="postgres"/>
	<tablespace name="pg_default"/>
</database>

<schema name="public" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<schema name="basic_auth" rect-visible="true" fill-color="#51980c">
	<role name="postgres"/>
</schema>

<extension name="pgcrypto" cur-version="1.2">
	<schema name="public"/>
	<comment><![CDATA[cryptographic functions]]></comment>
</extension>

<extension name="uuid-ossp" cur-version="1.0">
	<schema name="public"/>
	<comment><![CDATA[generate universally unique identifiers (UUIDs)]]></comment>
</extension>

<usertype name="jwt_claims" configuration="composite">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<typeattrib name="id">
		<type name="integer"/>
	</typeattrib>
	<typeattrib name="username">
		<type name="text"/>
	</typeattrib>
	<typeattrib name="logged_in_time">
		<type name="timestamp"/>
	</typeattrib>
	<typeattrib name="role">
		<type name="text"/>
	</typeattrib>
	<typeattrib name="email">
		<type name="text"/>
	</typeattrib>
</usertype>

<usertype name="token_type_enum" configuration="enumeration">
	<schema name="public"/>
	<role name="postgres"/>
	<enumeration values="validation,reset"/>
</usertype>

<function name="check_role_exists"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
begin
  if not exists (select 1 from pg_roles as r where r.rolname = new.role) then
    raise foreign_key_violation using message =
      'unknown database role: ' || new.role;
    return null;
  end if;
  return new;
end
]]></definition>
</function>

<function name="clearance_for_role"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="u">
		<type name="name"/>
	</parameter>
	<definition><![CDATA[
declare
  ok boolean;
begin
  select exists (
    select rolname
      from pg_authid
     where pg_has_role(current_user, oid, 'member')
       and rolname = u
  ) into ok;
  if not ok then
    raise invalid_password using message =
      'current user not member of role ' || u;
  end if;
end
]]></definition>
</function>

<function name="current_email"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<definition><![CDATA[
begin
  return current_setting('postgrest.claims.email');
exception
  -- handle unrecognized configuration parameter error
  when undefined_object then return '';
end;
]]></definition>
</function>

<function name="current_user_id"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<definition><![CDATA[
begin
  return current_setting('postgrest.claims.id')::integer;
exception
  -- handle unrecognized configuration parameter error
  when undefined_object then return NULL;
end;
]]></definition>
</function>

<function name="encrypt_pass"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
begin
  if tg_op = 'INSERT' or new.pass <> old.pass then
    new.pass = crypt(new.pass, gen_salt('bf'));
  end if;
  return new;
end
]]></definition>
</function>

<function name="send_validation"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
declare
  tok uuid;
begin
  select uuid_generate_v4() into tok;
  insert into basic_auth.tokens (token, token_type, user_id)
         values (tok, 'validation', new.id);
  perform pg_notify('validate',
    json_build_object(
      'email', new.email,
      'token', tok,
      'token_type', 'validation'
    )::text
  );
  return new;
end
]]></definition>
</function>

<function name="user_role"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="name"/>
	</return-type>
	<parameter name="email">
		<type name="text"/>
	</parameter>
	<parameter name="pass">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[
begin
  return (
  select role from basic_auth.users
   where (users.email = user_role.email or users.username = user_role.email)
     and users.pass = crypt(user_role.pass, users.pass)
  );
end;
]]></definition>
</function>

<function name="create_log_columns"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
DECLARE
 my_row RECORD;
BEGIN
 FOR my_row IN 
 SELECT table_name
 FROM information_schema.tables
 WHERE table_schema = 'public' and table_type='BASE TABLE'
 LOOP
 IF NOT EXISTS
 (
 SELECT attname FROM pg_attribute WHERE attrelid = 
 (SELECT oid FROM pg_class WHERE relname = my_row.table_name )
 AND attname = 'created_at'
 )
 THEN
 EXECUTE('ALTER TABLE ' || my_row.table_name || 
 ' ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,'||
 ' ADD COLUMN created_by INTEGER,' ||
 ' ADD COLUMN updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,'||
 ' ADD COLUMN updated_by INTEGER;'
 );
 END IF;
 END LOOP;
END
]]></definition>
</function>

<function name="create_log_triggers"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<definition><![CDATA[
DECLARE
 my_row RECORD;
BEGIN
 FOR my_row IN 
 SELECT table_name
 FROM information_schema.tables
 WHERE table_schema = 'public' and table_type='BASE TABLE'
 LOOP
 EXECUTE(
'DROP TRIGGER IF EXISTS log_insert_'||my_row.table_name||'_tf ON ' || my_row.table_name || ';' 
'DROP TRIGGER IF EXISTS log_update_'||my_row.table_name||'_tf ON ' || my_row.table_name || ';' 

'CREATE TRIGGER log_insert_'||my_row.table_name||'_tf BEFORE INSERT ON ' || my_row.table_name || ' FOR EACH ROW EXECUTE PROCEDURE log_insert();' 
'CREATE TRIGGER log_update_'||my_row.table_name||'_tf BEFORE UPDATE ON ' || my_row.table_name || ' FOR EACH ROW EXECUTE PROCEDURE log_update();'
 );

 END LOOP;
END
]]></definition>
</function>

<function name="log_insert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
  BEGIN
    NEW.created_at = NOW();
    NEW.created_by = basic_auth.current_user_id();
    RETURN NEW;
  END;
]]></definition>
</function>

<function name="log_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
  BEGIN
    NEW.updated_at = NOW();
    NEW.updated_by = basic_auth.current_user_id();
    RETURN NEW;
  END;
]]></definition>
</function>

<function name="login"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="basic_auth.jwt_claims"/>
	</return-type>
	<parameter name="email">
		<type name="text"/>
	</parameter>
	<parameter name="pass">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[
declare
  _role name;
  _username text; 
  _email text; 
  _logged_in_time timestamp without time zone;
  _id integer;  
  result basic_auth.jwt_claims;
begin
  select basic_auth.user_role(email, pass) into _role;

  if _role is null then
    raise invalid_password using message = 'invalid user or password';
  end if;
  -- TODO; check verified flag if you care whether users
  -- have validated their emails
  select t.id, t.username, t.email, LOCALTIMESTAMP INTO _id, _username, _email, _logged_in_time from basic_auth.users as t where t.email = login.email or t.username = login.email;

  select _id as id, _username as username, _logged_in_time as logged_in_time, _role as role, _email as email  into result;
  return result;
  
end;
]]></definition>
</function>

<function name="request_password_reset"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="email">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[
declare
  tok uuid;
begin
  delete from basic_auth.tokens
   where token_type = 'reset'
     and tokens.email = request_password_reset.email;

  select uuid_generate_v4() into tok;
  insert into basic_auth.tokens (token, token_type, email)
         values (tok, 'reset', request_password_reset.email);
  perform pg_notify('reset',
    json_build_object(
      'email', request_password_reset.email,
      'token', tok,
      'token_type', 'reset'
    )::text
  );
end;
]]></definition>
</function>

<function name="reset_password"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="email">
		<type name="text"/>
	</parameter>
	<parameter name="token">
		<type name="uuid"/>
	</parameter>
	<parameter name="pass">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[
declare
  tok uuid;
begin
  if exists(select 1 from basic_auth.tokens
             where tokens.email = reset_password.email
               and tokens.token = reset_password.token
               and token_type = 'reset') then
    update basic_auth.users set pass=reset_password.pass
     where users.email = reset_password.email;

    delete from basic_auth.tokens
     where tokens.email = reset_password.email
       and tokens.token = reset_password.token
       and token_type = 'reset';
  else
    raise invalid_password using message =
      'invalid user or token';
  end if;
  delete from basic_auth.tokens
   where token_type = 'reset'
     and tokens.email = reset_password.email;

  select uuid_generate_v4() into tok;
  insert into basic_auth.tokens (token, token_type, email)
         values (tok, 'reset', reset_password.email);
  perform pg_notify('reset',
    json_build_object(
      'email', reset_password.email,
      'token', tok
    )::text
  );
end;
]]></definition>
</function>

<function name="signup"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="sql" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="username">
		<type name="text"/>
	</parameter>
	<parameter name="email">
		<type name="text"/>
	</parameter>
	<parameter name="pass">
		<type name="text"/>
	</parameter>
	<definition><![CDATA[
  insert into basic_auth.users (username, email, pass, role) values
    (signup.username, signup.email, signup.pass, 'author');
]]></definition>
</function>

<function name="update_users"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="postgres"/>
	<language name="plpgsql" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
begin
  if tg_op = 'INSERT' then
    perform basic_auth.clearance_for_role(new.role);

    insert into basic_auth.users
      (username,role, pass, email, verified) values
      (new.username, coalesce(new.role, 'author'), new.pass,
        new.email, coalesce(new.verified, false));
    return new;
  elsif tg_op = 'UPDATE' then
    -- no need to check clearance for old.role because
    -- an ineligible row would not even available to update (http 404)
    perform basic_auth.clearance_for_role(new.role);

    update basic_auth.users set
      username = new.username,	
      email  = new.email,
      role   = new.role,
      pass   = new.pass,
      verified = coalesce(new.verified, old.verified, false)
      where email = old.email;
    return new;
  elsif tg_op = 'DELETE' then
    -- no need to check clearance for old.role (see previous case)

    delete from basic_auth.users
     where basic_auth.email = old.email;
    return null;
  end if;
end
]]></definition>
</function>

<table name="tokens">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<position x="562.158" y="102.857"/>
	<column name="token" not-null="true">
		<type name="uuid"/>
	</column>
	<column name="token_type" not-null="true">
		<type name="public.token_type_enum"/>
	</column>
	<column name="created_at" not-null="true" default-value="('now'::text)::date">
		<type name="timestamp with time zone" with-timezone="true"/>
	</column>
	<column name="user_id" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="tokens_pkey" type="pk-constr" table="basic_auth.tokens">
		<columns names="token" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="users_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="basic_auth"/>
	<role name="postgres"/>
</sequence>

<table name="users">
	<schema name="basic_auth"/>
	<role name="postgres"/>
	<position x="939.471" y="102.857"/>
	<column name="email" not-null="true">
		<type name="text"/>
	</column>
	<column name="pass" not-null="true">
		<type name="text"/>
	</column>
	<column name="role" not-null="true">
		<type name="name"/>
	</column>
	<column name="verified" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="username" not-null="true">
		<type name="text"/>
	</column>
	<column name="id" not-null="true" sequence="basic_auth.users_id_seq">
		<type name="integer"/>
	</column>
	<constraint name="users_email_check" type="ck-constr" table="basic_auth.users">
			<expression><![CDATA[(email ~* '^.+@.+\..+$'::text)]]></expression>
	</constraint>
	<constraint name="users_pass_check" type="ck-constr" table="basic_auth.users">
			<expression><![CDATA[(length(pass) < 512)]]></expression>
	</constraint>
	<constraint name="users_role_check" type="ck-constr" table="basic_auth.users">
			<expression><![CDATA[(length((role)::text) < 512)]]></expression>
	</constraint>
	<constraint name="users_email_unique" type="uq-constr" table="basic_auth.users">
		<columns names="email" ref-type="src-columns"/>
	</constraint>
	<constraint name="users_pkey" type="pk-constr" table="basic_auth.users">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="users_username_unique" type="uq-constr" table="basic_auth.users">
		<columns names="username" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="form_has_variables_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<table name="form_has_variables">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="570.143" y="373.429"/>
	<column name="id" not-null="true" sequence="public.form_has_variables_id_seq">
		<type name="integer"/>
	</column>
	<column name="form" not-null="true">
		<type name="integer"/>
	</column>
	<column name="variable" not-null="true">
		<type name="integer"/>
	</column>
	<column name="formula">
		<type name="text"/>
	</column>
	<column name="calc_order">
		<type name="integer"/>
	</column>
	<column name="token">
		<type name="character varying" length="50"/>
	</column>
	<constraint name="form_has_variable_pkey" type="pk-constr" table="public.form_has_variables">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="form_has_variable_uq" type="uq-constr" table="public.form_has_variables">
		<columns names="form,variable" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="forms_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<table name="forms">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="932.221" y="373.429"/>
	<column name="id" not-null="true" sequence="public.forms_id_seq">
		<type name="integer"/>
	</column>
	<column name="name" not-null="true">
		<type name="text"/>
	</column>
	<column name="type" not-null="true" default-value="'input'::text">
		<type name="text"/>
	</column>
	<constraint name="form_pkey" type="pk-constr" table="public.forms">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<view name="input_forms">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="949.143" y="701.829"/>
	<reference>
		<expression><![CDATA[ SELECT forms.id,
    forms.name,
    forms.type
   FROM forms
  WHERE (forms.type = 'input'::text);]]></expression>
	</reference>
</view>

<sequence name="sample_has_forms_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<sequence name="samples_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<view name="sample_forms">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1194.07" y="659.829"/>
	<reference>
		<expression><![CDATA[ SELECT samples.id,
    samples.identifier,
    samples.latitude,
    samples.longitude,
    sample_has_forms.id AS form_id
   FROM (samples
     JOIN sample_has_forms ON ((sample_has_forms.sample = samples.id)));]]></expression>
	</reference>
</view>

<table name="sample_has_forms">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1135.13" y="373.429"/>
	<column name="id" not-null="true" sequence="public.sample_has_forms_id_seq">
		<type name="integer"/>
	</column>
	<column name="form" not-null="true">
		<type name="integer"/>
	</column>
	<column name="sample" not-null="true">
		<type name="integer"/>
	</column>
	<column name="filled_on">
		<type name="timestamp"/>
	</column>
	<column name="filled_by">
		<type name="integer"/>
	</column>
	<column name="printed_on">
		<type name="timestamp"/>
	</column>
	<column name="printed_by">
		<type name="integer"/>
	</column>
	<column name="checked_on">
		<type name="timestamp"/>
	</column>
	<column name="checked_by">
		<type name="integer"/>
	</column>
	<constraint name="sample_has_form_pkey" type="pk-constr" table="public.sample_has_forms">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="sample_has_values_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<table name="sample_has_values">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1718.86" y="373.429"/>
	<column name="id" not-null="true" sequence="public.sample_has_values_id_seq">
		<type name="integer"/>
	</column>
	<column name="sample" not-null="true">
		<type name="integer"/>
	</column>
	<column name="variable" not-null="true">
		<type name="integer"/>
	</column>
	<column name="value">
		<type name="double precision"/>
	</column>
	<constraint name="sample_has_values_pkey" type="pk-constr" table="public.sample_has_values">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="sample_variable_ukey" type="uq-constr" table="public.sample_has_values">
		<columns names="sample,variable" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="variables_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="postgres"/>
</sequence>

<view name="sample_values">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1449.87" y="787.829"/>
	<reference>
		<expression><![CDATA[ SELECT sample_has_values.id,
    samples.id AS sample_id,
    forms.id AS form_id,
    variables.id AS variable_id,
    samples.identifier AS sample_identifier,
    forms.name AS form_name,
    forms.type AS form_type,
    variables.name,
    variables.data_type,
    variables.minimum,
    variables.maximum,
    variables.type,
    form_has_variables.formula,
    form_has_variables.calc_order,
        CASE
            WHEN (variables.type = 'constant'::text) THEN variables.default_value
            ELSE sample_has_values.value
        END AS value,
    form_has_variables.token
   FROM (((((samples
     JOIN sample_has_forms ON ((sample_has_forms.sample = samples.id)))
     JOIN forms ON ((sample_has_forms.form = forms.id)))
     JOIN form_has_variables ON ((form_has_variables.form = forms.id)))
     JOIN variables ON ((form_has_variables.variable = variables.id)))
     LEFT JOIN sample_has_values ON (((sample_has_values.sample = samples.id) AND (sample_has_values.variable = variables.id))));]]></expression>
	</reference>
</view>

<table name="samples">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1412.41" y="373.429"/>
	<column name="id" not-null="true" sequence="public.samples_id_seq">
		<type name="integer"/>
	</column>
	<column name="identifier" not-null="true">
		<type name="text"/>
	</column>
	<column name="latitude">
		<type name="double precision"/>
	</column>
	<column name="longitude">
		<type name="double precision"/>
	</column>
	<constraint name="sample_pkey" type="pk-constr" table="public.samples">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="sample_uq" type="uq-constr" table="public.samples">
		<columns names="identifier" ref-type="src-columns"/>
	</constraint>
</table>

<view name="users">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="1674.44" y="572.829"/>
	<reference>
		<expression><![CDATA[ SELECT actual.id,
    actual.role,
    '***'::text AS pass,
    actual.email,
    actual.verified
   FROM basic_auth.users actual,
    ( SELECT pg_authid.rolname
           FROM pg_authid
          WHERE pg_has_role("current_user"(), pg_authid.oid, 'member'::text)) member_of
  WHERE ((actual.role = member_of.rolname) AND ((actual.role <> 'author'::name) OR (actual.email = basic_auth.current_email())));]]></expression>
	</reference>
</view>

<table name="variables">
	<schema name="public"/>
	<role name="postgres"/>
	<position x="570.143" y="572.829"/>
	<column name="id" not-null="true" sequence="public.variables_id_seq">
		<type name="integer"/>
	</column>
	<column name="data_type" not-null="true" default-value="'number'::character varying">
		<type name="character varying" length="50"/>
	</column>
	<column name="name" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="default_value" not-null="true" default-value="0.0">
		<type name="double precision"/>
	</column>
	<column name="minimum">
		<type name="double precision"/>
	</column>
	<column name="maximum">
		<type name="double precision"/>
	</column>
	<column name="type" default-value="'input'::text">
		<type name="text"/>
	</column>
	<constraint name="variable_pkey" type="pk-constr" table="public.variables">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
	<constraint name="variable_ukey" type="uq-constr" table="public.variables">
		<columns names="name" ref-type="src-columns"/>
	</constraint>
</table>

<index name="fki_tokens_users_fkey" table="basic_auth.tokens"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="user_id"/>
		</idxelement>
</index>

<trigger name="encrypt_pass" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="basic_auth.users">
		<function signature="basic_auth.encrypt_pass()"/>
</trigger>

<trigger name="ensure_user_role_exists" firing-type="AFTER" per-line="true" constraint="true"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="basic_auth.users">
		<function signature="basic_auth.check_role_exists()"/>
</trigger>

<trigger name="send_validation" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="basic_auth.users">
		<function signature="basic_auth.send_validation()"/>
</trigger>

<constraint name="tokens_users_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="basic_auth.users" table="basic_auth.tokens">
	<columns names="user_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="form_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.forms" table="public.form_has_variables">
	<columns names="form" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="variable_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.variables" table="public.form_has_variables">
	<columns names="variable" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="form_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.forms" table="public.sample_has_forms">
	<columns names="form" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="sample_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.samples" table="public.sample_has_forms">
	<columns names="sample" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="sample_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.samples" table="public.sample_has_values">
	<columns names="sample" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="value_fkey" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="public.variables" table="public.sample_has_values">
	<columns names="variable" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_tokens_users" type="relfk"
	 custom-color="#8810cf"
	 src-table="basic_auth.tokens"
	 dst-table="basic_auth.users"
	 src-required="false" dst-required="false"/>

<relationship name="rel_form_has_variables_forms" type="relfk"
	 custom-color="#dd9fb3"
	 src-table="public.form_has_variables"
	 dst-table="public.forms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_form_has_variables_variables" type="relfk"
	 custom-color="#231771"
	 src-table="public.form_has_variables"
	 dst-table="public.variables"
	 src-required="false" dst-required="false"/>

<relationship name="rel_sample_has_forms_forms" type="relfk"
	 custom-color="#5542c3"
	 src-table="public.sample_has_forms"
	 dst-table="public.forms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_sample_has_forms_samples" type="relfk"
	 custom-color="#a15c2e"
	 src-table="public.sample_has_forms"
	 dst-table="public.samples"
	 src-required="false" dst-required="false"/>

<relationship name="rel_sample_has_values_samples" type="relfk"
	 custom-color="#af0745"
	 src-table="public.sample_has_values"
	 dst-table="public.samples"
	 src-required="false" dst-required="false"/>

<relationship name="rel_sample_has_values_variables" type="relfk"
	 custom-color="#3e8147"
	 src-table="public.sample_has_values"
	 dst-table="public.variables"
	 src-required="false" dst-required="false"/>

<permission>
	<object name="basic_auth" type="schema"/>
	<roles names="postgres"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="basic_auth" type="schema"/>
	<roles names="anon"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="basic_auth" type="schema"/>
	<roles names="author"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="public.request_password_reset(text)" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.request_password_reset(text)" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.request_password_reset(text)" type="function"/>
	<roles names="anon"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.reset_password(text,uuid,text)" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.reset_password(text,uuid,text)" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.reset_password(text,uuid,text)" type="function"/>
	<roles names="anon"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.signup(text,text,text)" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.signup(text,text,text)" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="public.signup(text,text,text)" type="function"/>
	<roles names="anon"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="basic_auth.tokens" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="basic_auth.tokens" type="table"/>
	<roles names="anon"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="basic_auth.tokens" type="table"/>
	<roles names="author"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="basic_auth.users" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="basic_auth.users" type="table"/>
	<roles names="anon"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
<permission>
	<object name="basic_auth.users" type="table"/>
	<roles names="author"/>
	<privileges select="true" delete="true" insert="true" update="true"/>
</permission>
</dbmodel>
